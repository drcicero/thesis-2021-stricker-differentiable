\chapter{Conclusion}
In this work we have implemented forward and reverse mode differentiation in multiple ways. By starting with the mathematical foundations of reverse mode differentiation we have developed each implementation incrementally. By doing that we have seen that the core design of each implementation is similar but each design decision also has consequences. Implementations which are purer tend to perform worse which goes so far that we would say our purest implementation (CHAD) isn't usable in real life tasks. In terms of API usability and functionality the result are mixed. There seems to be no correlation between API and other metrics but our fastest implementation has an unpleasant API. We also learned that our implementations have different nesting limits which could be an indicator for how complex a function supported by our implementation can be.